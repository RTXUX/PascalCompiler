namespace PascalCompiler.Lexical.Lexer {
    using ActiproSoftware.Text;
    using ActiproSoftware.Text.Lexing.Implementation;
    using ActiproSoftware.Text.Utility;
    using System;
    
    
    /// <summary>
    /// Represents a lexer for the <c>Pascal</c> language.
    /// </summary>
    /// <remarks>
    /// This type was generated by the Actipro Language Designer tool v19.1.685.0 (http://www.actiprosoftware.com).
    /// Generated code is based on input created by Actipro Software LLC.
    /// Copyright (c) 2001-2020 Actipro Software LLC.  All rights reserved.
    /// </remarks>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("LanguageDesigner", "19.1.685.0")]
    public partial class PascalLexer : DynamicLexer {
        
        /// <summary>
        /// Initializes a new instance of the <c>PascalLexer</c> class.
        /// </summary>
        /// <param name="classificationTypeProvider">A <see cref="IPascalClassificationTypeProvider"/> that provides classification types used by this lexer.</param>
        public PascalLexer(IPascalClassificationTypeProvider classificationTypeProvider) {
            if ((classificationTypeProvider == null)) {
                throw new ArgumentNullException("classificationTypeProvider");
            }

            // Create lexical macros
            this.LexicalMacros.Add(new DynamicLexicalMacro("Word", "[a-zA-Z0-9]"));
            this.LexicalMacros.Add(new DynamicLexicalMacro("NonWord", "[^a-zA-Z0-9]"));

            // Create lexical states
            IKeyedObservableCollection<DynamicLexicalState> lexicalStates = ((IKeyedObservableCollection<DynamicLexicalState>)(this.LexicalStates));
            this.DefaultLexicalState.Id = PascalLexicalStateId.Default;
            lexicalStates.Add(new DynamicLexicalState(PascalLexicalStateId.PrimaryString, "PrimaryString"));
            lexicalStates.Add(new DynamicLexicalState(PascalLexicalStateId.MultiLineComment, "MultiLineComment"));

            DynamicLexicalState lexicalState = null;
            DynamicLexicalScope lexicalScope = null;
            DynamicLexicalPatternGroup lexicalPatternGroup = null;

            // Initialize the Default lexical state
            lexicalState = lexicalStates["Default"];
            lexicalState.ChildLexicalStates.Add(lexicalStates["PrimaryString"]);
            lexicalState.ChildLexicalStates.Add(lexicalStates["MultiLineComment"]);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "Whitespace", null);
            lexicalPatternGroup.TokenId = PascalTokenId.Whitespace;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("{Whitespace}+"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "LineTerminator", null);
            lexicalPatternGroup.TokenId = PascalTokenId.LineTerminator;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("{LineTerminator}"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "OpenParenthesis", null);
            lexicalPatternGroup.TokenId = PascalTokenId.OpenParenthesis;
            lexicalPatternGroup.LookAheadPattern = "$|[^\\*\\.]";
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("("));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "CloseParenthesis", null);
            lexicalPatternGroup.TokenId = PascalTokenId.CloseParenthesis;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern(")"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "OpenSquareBrace", null);
            lexicalPatternGroup.TokenId = PascalTokenId.OpenSquareBrace;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("\\["));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("\\(\\."));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "CloseSquareBrace", null);
            lexicalPatternGroup.TokenId = PascalTokenId.CloseSquareBrace;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("\\]"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("\\.\\)"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "Punctuation", null);
            lexicalPatternGroup.TokenId = PascalTokenId.Punctuation;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern(".. . , : ; ^ @"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "Keyword", classificationTypeProvider.Keyword);
            lexicalPatternGroup.TokenId = PascalTokenId.Keyword;
            lexicalPatternGroup.CaseSensitivity = CaseSensitivity.Sensitive;
            lexicalPatternGroup.LookAheadPattern = "{NonWord}|\\z";
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("and"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("array"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("begin"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("case"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("const"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("div"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("downto"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("do"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("else"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("end"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("file"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("for"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("function"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("goto"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("if"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("in"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("label"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("mod"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("nil"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("not"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("of"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("or"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("packed"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("procedure"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("program"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("record"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("repeat"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("set"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("then"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("to"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("type"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("until"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("var"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("while"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("with"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "Identifier", classificationTypeProvider.Identifier);
            lexicalPatternGroup.TokenId = PascalTokenId.Identifier;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("{Alpha}({Word})*"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "Operator", classificationTypeProvider.Operator);
            lexicalPatternGroup.TokenId = PascalTokenId.Operator;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("*"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("+"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("-"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("/"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern(":="));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("<="));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("<>"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("<"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("="));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern(">="));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern(">"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "RealNumber", classificationTypeProvider.Number);
            lexicalPatternGroup.TokenId = PascalTokenId.RealNumber;
            lexicalPatternGroup.LookAheadPattern = "{NonWord}|\\z";
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("[\\+\\-]? {Digit}+ \\. {Digit}+ (e [\\+\\-]? {Digit}+)?"));
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("[\\+\\-]? {Digit}+ e [\\+\\-]? {Digit}+"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "IntegerNumber", classificationTypeProvider.Number);
            lexicalPatternGroup.TokenId = PascalTokenId.IntegerNumber;
            lexicalPatternGroup.LookAheadPattern = "{NonWord}|\\z";
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("[\\+\\-]? {Digit}+"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);

            // Initialize the PrimaryString lexical state
            lexicalState = lexicalStates["PrimaryString"];
            lexicalState.DefaultClassificationType = classificationTypeProvider.String;
            lexicalState.DefaultTokenId = PascalTokenId.PrimaryStringText;
            lexicalState.DefaultTokenKey = "PrimaryStringText";
            lexicalScope = new DynamicLexicalScope();
            lexicalState.LexicalScopes.Add(lexicalScope);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "PrimaryStringStartDelimiter", null);
            lexicalPatternGroup.TokenId = PascalTokenId.PrimaryStringStartDelimiter;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("\""));
            lexicalScope.StartLexicalPatternGroup = lexicalPatternGroup;
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "PrimaryStringEndDelimiter", null);
            lexicalPatternGroup.TokenId = PascalTokenId.PrimaryStringEndDelimiter;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("((?<!\\\\)\\\"|\\n)"));
            lexicalScope.EndLexicalPatternGroup = lexicalPatternGroup;
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "PrimaryStringEscapedDelimiter", null);
            lexicalPatternGroup.TokenId = PascalTokenId.PrimaryStringEscapedDelimiter;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("\"\""));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "PrimaryStringText", null);
            lexicalPatternGroup.TokenId = PascalTokenId.PrimaryStringText;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("(\\\\\"|[^\"\\n])+"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);

            // Initialize the MultiLineComment lexical state
            lexicalState = lexicalStates["MultiLineComment"];
            lexicalState.DefaultClassificationType = classificationTypeProvider.Comment;
            lexicalState.DefaultTokenId = PascalTokenId.MultiLineCommentText;
            lexicalState.DefaultTokenKey = "MultiLineCommentText";
            lexicalScope = new DynamicLexicalScope();
            lexicalState.LexicalScopes.Add(lexicalScope);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "MultiLineCommentStartDelimiter", null);
            lexicalPatternGroup.TokenId = PascalTokenId.MultiLineCommentStartDelimiter;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("{"));
            lexicalScope.StartLexicalPatternGroup = lexicalPatternGroup;
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "MultiLineCommentEndDelimiter", null);
            lexicalPatternGroup.TokenId = PascalTokenId.MultiLineCommentEndDelimiter;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("}"));
            lexicalScope.EndLexicalPatternGroup = lexicalPatternGroup;
            lexicalScope = new DynamicLexicalScope();
            lexicalState.LexicalScopes.Add(lexicalScope);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "MultiLineCommentStartDelimiter", null);
            lexicalPatternGroup.TokenId = PascalTokenId.MultiLineCommentStartDelimiter;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("(*"));
            lexicalScope.StartLexicalPatternGroup = lexicalPatternGroup;
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Explicit, "MultiLineCommentEndDelimiter", null);
            lexicalPatternGroup.TokenId = PascalTokenId.MultiLineCommentEndDelimiter;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("*)"));
            lexicalScope.EndLexicalPatternGroup = lexicalPatternGroup;
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "MultiLineCommentLineTerminator", null);
            lexicalPatternGroup.TokenId = PascalTokenId.MultiLineCommentLineTerminator;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("\\n"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
            lexicalPatternGroup = new DynamicLexicalPatternGroup(DynamicLexicalPatternType.Regex, "MultiLineCommentText", null);
            lexicalPatternGroup.TokenId = PascalTokenId.MultiLineCommentText;
            lexicalPatternGroup.Patterns.Add(new DynamicLexicalPattern("[^\\}\\*\\n]+"));
            lexicalState.LexicalPatternGroups.Add(lexicalPatternGroup);
        }
    }
}
